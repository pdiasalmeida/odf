#include <cstdlib>

#include <vector>
#include <string>

#include <libconfig.h++>

#include "../libs/easylogging++.h"
#include "../plugins/Kernel.h"

INITIALIZE_EASYLOGGINGPP

static const int ODF_PROCESS_DIR = 0;
static const int ODF_PROCESS_IMAGE = 1;
static const int ODF_PROCESS_FILE = 2;
static const int ODF_PROCESS_METADATA = 3;
static const int ODF_LAUNCH_SERVICE = 4;

static const std::string ODF_APP_CONFIG_PATH = std::string("config/sample.conf");
static const std::string ODF_LOG_CONFIG_PATH = std::string("config/log.conf");

std::vector< std::string > validExtensions;

PluginEngine::Kernel pluginKernel;

std::string processDir;
std::string outputDir;
std::string configPath;
std::string imagePath;
std::string infoFile;
std::string socketPath;

bool fromMetadata = false;
bool debug = false;
bool silent = false;
bool saveThumbs = false;

int idT = -1;
int idV = -1;

int topLx = -1;
int topLy = -1;
int bottRx = -1;
int bottRy = -1;

int parseArgs(int nArgs, char** arguments)
{
	int process_mode = -1;
	if (nArgs >= 2) {
		for (int i = 1; i < nArgs; i++) {
			std::string opt = std::string(arguments[i]);
			if (opt == "-d") {
				processDir = std::string(arguments[i+1]);
				i++;
			} if (opt == "-o") {
				outputDir = std::string(arguments[i+1]);
				mkdir(outputDir.c_str(), 0777);
				i++;
			} if (opt == "-i") {
				imagePath = std::string(arguments[i+1]);
				i++;
			} if (opt == "-v") {
				debug = true;
			} if (opt == "-s") {
				silent = true;
			} if (opt == "-st") {
				saveThumbs = true;
			} if (opt == "-f") {
				infoFile = std::string(arguments[i+1]);
			} if (opt == "-m") {
				fromMetadata = true;
			} if (opt == "-idt") {
				idT = atoi(arguments[i+1]);
			} if (opt == "-idv") {
				idV = atoi(arguments[i+1]);
			} if (opt == "-srv") {
				socketPath = std::string(arguments[i+1]);
			} if (opt == "-bb") {
				topLx = atoi(arguments[i+1]);
				topLy = atoi(arguments[i+2]);
				bottRx = atoi(arguments[i+3]);
				bottRy = atoi(arguments[i+4]);
			} if (opt == "-cf") {
				configPath = std::string(arguments[i+1]);
			}
		}
	}

	if (!processDir.empty() && !fromMetadata) {
		process_mode = ODF_PROCESS_DIR;
	} else if (!processDir.empty() && fromMetadata) {
		process_mode = ODF_PROCESS_METADATA;
	} else if (!imagePath.empty()) {
		process_mode = ODF_PROCESS_IMAGE;
	} else if (!infoFile.empty()) {
		process_mode = ODF_PROCESS_FILE;
	} else if (!socketPath.empty()) {
		process_mode = ODF_LAUNCH_SERVICE;
	} else {
		LOG(ERROR) << "Unable to start application with arguments provided.";
		// print help
	}

	return process_mode;
}

int parseConfig()
{
	int status = EXIT_SUCCESS;

	libconfig::Config cfg;
	try {
		// load config file
		cfg.readFile(configPath.c_str());

		// parse plugins to load and load them
		libconfig::Setting &plugins = cfg.lookup("ODF.plugins");
		int pluginCount = plugins.getLength();
		for (int i = 0; i < pluginCount; ++i) {
			std::string pluginFilePath;
			libconfig::Setting &plugin = plugins[i];

			plugin.lookupValue("file", pluginFilePath);
			pluginKernel.loadPlugin(pluginFilePath);
		}
	} catch (libconfig::FileIOException &fioex) {
		status = EXIT_FAILURE;
		LOG(ERROR) << "Error loading config file: " << fioex.what()
				<< ".\n\tTry checking if you have the correct path to the file."
				<< std::endl;
	} catch (libconfig::ParseException &pex) {
		status = EXIT_FAILURE;
		LOG(ERROR) << "Error parsing config file: " << pex.what()
				<< ".\n\tPlease check the format of the contents in the file."
				<< std::endl;
	} catch (std::runtime_error &rter) {
		status = EXIT_FAILURE;
		LOG(ERROR) << "Error loading plugin: " << rter.what()
				<< ".\n\tPlease check if plugin file exists in this path."
				<< std::endl;
	}

	return status;
}

int main(int argc, char** argv)
{
	int status = EXIT_SUCCESS;
	configPath = ODF_APP_CONFIG_PATH;

	// initialize logger
	el::Configurations logConf(ODF_LOG_CONFIG_PATH);
	el::Loggers::reconfigureAllLoggers(logConf);

	// types of image that we will be accepting
	validExtensions.push_back("jpg");
	validExtensions.push_back("png");
	validExtensions.push_back("ppm");

	// output files generated by ORF with detection results
	validExtensions.push_back("dat");

	// parse arguments and determine execution mode of the application
	int execMode = parseArgs(argc, argv);

	// parse config to retrieve information about the modules to use in detection, classification,
	// output, etc.
	// if (execMode != -1)
		status = parseConfig();

	if (status == 0) {
		switch (execMode) {
			case ODF_PROCESS_DIR:
				break;
			case ODF_PROCESS_METADATA:
				break;
			case ODF_PROCESS_IMAGE:
				break;
			case ODF_PROCESS_FILE:
				break;
			case ODF_LAUNCH_SERVICE:
				break;
			default:
				status = EXIT_FAILURE;
				break;
		}
	}

	return status;
}
