#include <cstdlib>

#include <vector>
#include <string>

#include <libconfig.h++>

#include "../libs/easylogging++.h"

#include "../plugins/Common.h"
#include "../plugins/Kernel.h"
#include "../plugins/DetectorFactory.h"
#include "../plugins/DataStoreFactory.h"

#include "auxiliar/FilesHelper.hpp"

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

INITIALIZE_EASYLOGGINGPP

using namespace PluginEngine;

static const int ODF_PROCESS_DIR = 0;
static const int ODF_PROCESS_IMAGE = 1;
static const int ODF_PROCESS_FILE = 2;
static const int ODF_PROCESS_METADATA = 3;
static const int ODF_LAUNCH_SERVICE = 4;

static const std::string ODF_APP_CONFIG_PATH = std::string("config/sample.conf");
static const std::string ODF_LOG_CONFIG_PATH = std::string("config/log.conf");

int parseArgs(int nArgs, char** arguments);
int parseConfig();
void doDetectionProcess(cv::Mat frame, std::string fileName);
int processDirectory();
int processImage();
int getPreviousProgress(int outputType); // 0 = images || 1 = text files

std::vector<std::string> fileNames;
std::vector<std::string> processed;
std::vector<std::string> toProcess;
std::vector<std::string> validImageExtensions;
std::vector<std::string> validFileExtensions;

Kernel pluginKernel;

std::string processDir;
std::string outputDir;
std::string configPath;
std::string imagePath;
std::string infoFile;
std::string socketPath;

bool fromMetadata = false;
bool debug = false;
bool silent = false;
bool saveThumbs = false;

int outputMethod = 0; // 0 = NOP | 1 = DRAW | 2 = BLUR

int idT = -1;
int idV = -1;

int topLx = -1;
int topLy = -1;
int bottRx = -1;
int bottRy = -1;

typedef struct Detection {
	std::string name;
	DetectorFactory::Detector *detector;
	DataStoreFactory::DataStore *dataStore;
} Detection;

std::vector<Detection> _detections;

int main(int argc, char** argv)
{
	int status = EXIT_SUCCESS;
	configPath = ODF_APP_CONFIG_PATH;

	// initialize logger
	el::Configurations logConf(ODF_LOG_CONFIG_PATH);
	el::Loggers::reconfigureAllLoggers(logConf);

	// types of image that we will be accepting
	validImageExtensions.push_back("jpg");
	validImageExtensions.push_back("png");
	validImageExtensions.push_back("ppm");

	// output files generated by ODF with detection results
	validFileExtensions.push_back("dat");

	// parse arguments and determine execution mode of the application
	int execMode = parseArgs(argc, argv);

	// parse config to retrieve information about the modules to use in detection, classification,
	// output, etc.
	if (execMode != -1)
		status = parseConfig();

	if (status == 0) {
		switch (execMode) {
			case ODF_PROCESS_DIR:
				status = processDirectory();
				break;
			case ODF_PROCESS_METADATA:
				break;
			case ODF_PROCESS_IMAGE:
				status = processImage();
				break;
			case ODF_PROCESS_FILE:
				break;
			case ODF_LAUNCH_SERVICE:
				break;
			default:
				status = EXIT_FAILURE;
				break;
		}
	}

	return status;
}

int parseArgs(int nArgs, char** arguments)
{
	int process_mode = -1;
	if (nArgs >= 2) {
		for (int i = 1; i < nArgs; i++) {
			std::string opt = std::string(arguments[i]);
			if (opt == "-d") {
				processDir = std::string(arguments[i+1]);
				i++;
			} if (opt == "-o") {
				outputDir = std::string(arguments[i+1]);
				mkdir(outputDir.c_str(), 0777);
				i++;
			} if (opt == "-i") {
				imagePath = std::string(arguments[i+1]);
				i++;
			} if (opt == "-f") {
				infoFile = std::string(arguments[i+1]);
			} if (opt == "-m") {
				fromMetadata = true;
			} if (opt == "-idt") {
				idT = atoi(arguments[i+1]);
			} if (opt == "-idv") {
				idV = atoi(arguments[i+1]);
			} if (opt == "-srv") {
				socketPath = std::string(arguments[i+1]);
			} if (opt == "-bb") {
				topLx = atoi(arguments[i+1]);
				topLy = atoi(arguments[i+2]);
				bottRx = atoi(arguments[i+3]);
				bottRy = atoi(arguments[i+4]);
			} if (opt == "-cf") {
				configPath = std::string(arguments[i+1]);
			}
		}
	}

	if (!processDir.empty() && !fromMetadata) {
		process_mode = ODF_PROCESS_DIR;
	} else if (!processDir.empty() && fromMetadata) {
		process_mode = ODF_PROCESS_METADATA;
	} else if (!imagePath.empty()) {
		process_mode = ODF_PROCESS_IMAGE;
	} else if (!infoFile.empty()) {
		process_mode = ODF_PROCESS_FILE;
	} else if (!socketPath.empty()) {
		process_mode = ODF_LAUNCH_SERVICE;
	} else {
		LOG(ERROR) << "Unable to start application with arguments provided.";
		// print help
	}

	return process_mode;
}

int parseConfig()
{
	int status = EXIT_SUCCESS;

	libconfig::Config cfg;
	try {
		// load config file
		cfg.readFile(configPath.c_str());

		// if process_dir || output_dir not given in command line search value in config
		if (processDir.empty())
			cfg.lookupValue("ODF.process_directory", processDir);
		if (outputDir.empty())
			cfg.lookupValue("ODF.output_directory", outputDir);

		cfg.lookupValue("ODF.output_method", outputMethod);

		cfg.lookupValue("ODF.debug", debug);
		cfg.lookupValue("ODF.silent", silent);
		cfg.lookupValue("ODF.saveThumbs", saveThumbs);

		// parse plugins to load and load them
		libconfig::Setting &plugins = cfg.lookup("ODF.plugins");
		int pluginCount = plugins.getLength();
		for (int i = 0; i < pluginCount; ++i) {
			std::string pluginName;
			std::string pluginFilePath;
			libconfig::Setting &plugin = plugins[i];

			plugin.lookupValue("file", pluginFilePath);
			plugin.lookupValue("name", pluginName);

			// build argument map
			std::map<std::string, std::string> args;
			args.insert(std::make_pair("name", pluginName));

			libconfig::Setting &pluginArgs = cfg.lookup("ODF.plugins.["
					+ std::to_string(i) + "].args");

			int argCount = pluginArgs.getLength();
			for (int n = 0; n < argCount; ++n) {
				std::string argName = pluginArgs[n].getName();
				std::string argValue;
				pluginArgs.lookupValue(argName, argValue);

				args.insert(std::make_pair(argName, argValue));
			}

			pluginKernel.loadPlugin(pluginFilePath, args);
		}

		// get detections expected for the framework
		libconfig::Setting &detections = cfg.lookup("ODF.detections");
		int detectionCount = detections.getLength();
		for (int i = 0; i < detectionCount; ++i) {
			Detection d;
			std::string dataStorePluginName;
			std::string detectorPluginName;
			libconfig::Setting &detection = detections[i];

			detection.lookupValue("name", d.name);
			// parse data store to use and get reference to it
			detection.lookupValue("dataStore.pluginName", dataStorePluginName);
			d.dataStore = &pluginKernel.getDataStoreFactory().getDataStore(dataStorePluginName);
			// parse detector to use and get reference to it
			detection.lookupValue("detector.pluginName", detectorPluginName);
			d.detector = &pluginKernel.getDetectorFactory().getDetector(detectorPluginName);

			_detections.push_back(d);
		}
	} catch (libconfig::FileIOException &fioex) {
		status = EXIT_FAILURE;
		LOG(ERROR) << "Error loading config file: " << fioex.what()
				<< ".\n\tTry checking if you have the correct path to the file."
				<< std::endl;
	} catch (libconfig::ParseException &pex) {
		status = EXIT_FAILURE;
		LOG(ERROR) << "Error parsing config file: " << pex.what()
				<< ".\n\tPlease check the format of the contents in the file."
				<< std::endl;
	} catch (std::runtime_error &rter) {
		status = EXIT_FAILURE;
		LOG(ERROR) << "Error loading plugin: " << rter.what()
				<< ".\n\tPlease check if plugin file exists in this path."
				<< std::endl;
	}

	return status;
}

void saveBlurredResults(cv::Mat image, std::string name, std::vector<Rect> foundobjs)
{
	if (debug) std::cout << "Saving detector results ..." << std::endl;

	std::vector<Rect>::iterator it = foundobjs.begin();
	for ( ; it != foundobjs.end(); it++ ) {
		cv::Rect obj(it->x, it->y, it->width, it->height);
		cv::Mat pplate = image(obj);
		cv::GaussianBlur(pplate,pplate,cv::Size(15,15), 100.0);
	}
	cv::imwrite( outputDir+"/"+FilesHelper::getFileName(name), image );

	if (debug) std::cout << "Finished saving detector results." << std::endl;
}

void saveDrawnResults(cv::Mat image, std::string name, std::vector<Rect> foundobjs)
{
	if (debug) std::cout << "Saving detector results ..." << std::endl;

	std::vector<Rect>::iterator it = foundobjs.begin();
	for ( ; it != foundobjs.end(); it++ ) {
		cv::Rect obj(it->x, it->y, it->width, it->height);
		cv::rectangle(image, obj, cv::Scalar(255 ,0 ,0), 6);
	}
	cv::imwrite(outputDir+"/"+FilesHelper::getFileName(name), image);

	if (debug) std::cout << "Finished saving detector results." << std::endl;
}

int processDirectory()
{
	int status = EXIT_SUCCESS;

	// Get directory with input images
	if (processDir.empty()) {
		processDir = "./benchmark";
		if (!silent)
			LOG(INFO) << "No processing directory given. Proceeding with benchmark."
			<< std::endl;
	}
	if (outputDir.empty()) {
		outputDir = processDir + "_out";
		if (!silent)
			LOG(INFO) << "No output directory given. Saving results to "
			<< outputDir << "." << std::endl;
	}
	mkdir(outputDir.c_str(), 0777);

	// Get files in input directory and discover previous progress
	FilesHelper::getFilesInDirectory(processDir, fileNames, validImageExtensions);
	int n = getPreviousProgress(0);

	// Begin/continue processing files according with the current configuration
	std::vector<std::string>::iterator itFN = toProcess.begin();
	for (int total = fileNames.size() ; itFN != toProcess.end(); itFN++) {
		if (!silent)
			LOG(INFO) << "Processing file " << *itFN << " ..." << std::endl;

		cv::Mat frame = cv::imread(processDir + "/" + *itFN);

		doDetectionProcess(frame, *itFN);
		n++;

		if (!silent)
			std::cout << "\tFinished processing file " << *itFN << ". "
			<< std::endl << (float) n/total * 100 << "% complete." << std::endl;
	}

	return status;
}

int processImage()
{
	int status = EXIT_SUCCESS;

	if (outputDir.empty()) {
		outputDir = "out";
		if (!silent)
			std::cout << "No output directory given. Saving results to "
			<< outputDir << "." << std::endl;
	}
	mkdir(outputDir.c_str(), 0777);

	if (FilesHelper::fileAvailable(FilesHelper::getDirName(imagePath),
			FilesHelper::getFileName(imagePath), validImageExtensions)) {
		cv::Mat image = cv::imread(imagePath);
		cv::Mat frame;

		if (topLx!=-1 && topLy!=-1 && bottRx!=-1 && bottRy!=-1)
			frame = image(cv::Rect(topLx, topLy, bottRx-topLx, bottRy-topLy));
		else
			frame = image;

		doDetectionProcess(frame, imagePath);

	} else {
		std::cout << "Unable to access requested file '" << processDir + "/" + imagePath
				<< "' or incompatible extension. Terminating process." << std::endl;
		status = EXIT_FAILURE;
	}

	return status;
}

void doDetectionProcess(cv::Mat frame, std::string fileName)
{
	std::vector<Detection>::iterator dit = _detections.begin();
	for( ; dit != _detections.end(); dit ++ ) {
		std::vector<Rect> objects = dit->detector->detect(frame.data, frame.cols, frame.rows, frame.type());

		if (dit->dataStore) {
			dit->dataStore->writeAnnotations(fileName, dit->name, objects);
		}

		switch (outputMethod) {
			case 1:
				saveDrawnResults(frame, fileName, objects);
				break;
			case 2:
				saveBlurredResults(frame, fileName, objects);
				break;
			default:
				// nop
				break;
		}
	}
}

bool cmp(std::string a, std::string b)
{
    return FilesHelper::getFileNameNoExt(a).compare(FilesHelper::getFileNameNoExt(b));
}

int getPreviousProgress(int outputType)
{
	(outputType == 0) ?
			FilesHelper::getFilesInDirectory(outputDir, processed, validImageExtensions) :
			FilesHelper::getFilesInDirectory(outputDir, processed, validFileExtensions);

	std::sort(fileNames.begin(), fileNames.end());
	std::sort(processed.begin(), processed.end());

	std::set_difference(fileNames.begin(), fileNames.end(), processed.begin(),
			processed.end(), std::back_inserter(toProcess), cmp);

	return processed.size();
}

